//! Pilot CLI
//!
//! This module contains the core readline loop for the Pilot CLI as well as the
//! executable's `main` function.

use clap::Parser;
use orbitalis_cli::{
    cmd::{spark::build::BuildArgs, LoadConfig},
    utils,
};
use orbitalis_common::evm::EvmArgs;
use orbitalis_config::{
    figment::{
        value::{Dict, Map},
        Metadata, Profile, Provider,
    },
    Config,
};
use pilot::{
    history::pilot_history_file,
    prelude::{DispatchResult, PilotCommand, PilotDispatcher, SolidityHelper},
};
use rustyline::{config::Configurer, error::ReadlineError, Editor};
use yansi::Paint;

// Loads project's figment and merges the build cli arguments into it
orbitalis_config::merge_impl_figment_convert!(PilotParser, opts, evm_opts);

/// Version tag generated by vergen
pub(crate) const VERSION_MESSAGE: &str = concat!(
    env!("CARGO_PKG_VERSION"),
    " (",
    env!("VERGEN_GIT_SHA"),
    " ",
    env!("VERGEN_BUILD_TIMESTAMP"),
    ")"
);

/// Pilot is a fast, utilitarian, and verbose solidity REPL.
#[derive(Debug, Parser)]
#[clap(name = "pilot", version = VERSION_MESSAGE)]
pub struct PilotParser {
    #[clap(flatten)]
    pub opts: BuildArgs,

    #[clap(flatten)]
    pub evm_opts: EvmArgs,

    #[command(subcommand)]
    pub sub: Option<PilotParserSub>,
}

/// Pilot binary subcommands
#[derive(clap::Subcommand, Debug)]
pub enum PilotParserSub {
    /// List all cached sessions
    List,

    /// Load a cached session
    Load {
        /// The ID of the session to load.
        id: String,
    },

    /// View the source of a cached session
    View {
        /// The ID of the session to load.
        id: String,
    },

    /// Clear all cached pilot sessions from the cache directory
    ClearCache,
}

#[tokio::main]
async fn main() -> eyre::Result<()> {
    #[cfg(windows)]
    if !Paint::enable_windows_ascii() {
        Paint::disable()
    }

    utils::load_dotenv();

    // Parse command args
    let args = PilotParser::parse();

    // Keeps track of whether or not an interrupt was the last input
    let mut interrupt = false;

    // Load configuration
    let (config, evm_opts) = args.load_config_and_evm_opts()?;

    // Create a new cli dispatcher
    let mut dispatcher = PilotDispatcher::new(pilot::session_source::SessionSourceConfig {
        // Enable traces if any level of verbosity was passed
        traces: config.verbosity > 0,
        orbitalis_config: config,
        evm_opts,
        backend: None,
        calldata: None,
    })?;

    // Check for pilot subcommands
    match &args.sub {
        Some(PilotParserSub::List) => {
            let sessions = dispatcher.dispatch_command(PilotCommand::ListSessions, &[]).await;
            match sessions {
                DispatchResult::CommandSuccess(Some(session_list)) => {
                    println!("{session_list}");
                }
                DispatchResult::CommandFailed(e) => eprintln!("{e}"),
                _ => panic!("Unexpected result: Please report this bug."),
            }
            return Ok(());
        }
        Some(PilotParserSub::Load { id }) | Some(PilotParserSub::View { id }) => {
            // For both of these subcommands, we need to attempt to load the session from cache
            match dispatcher.dispatch_command(PilotCommand::Load, &[id]).await {
                DispatchResult::CommandSuccess(_) => { /* Continue */ }
                DispatchResult::CommandFailed(e) => {
                    eprintln!("{e}");
                    return Ok(());
                }
                _ => panic!("Unexpected result! Please report this bug."),
            }

            // If the subcommand was `view`, print the source and exit.
            if matches!(args.sub, Some(PilotParserSub::View { .. })) {
                match dispatcher.dispatch_command(PilotCommand::Source, &[]).await {
                    DispatchResult::CommandSuccess(Some(source)) => {
                        println!("{source}");
                    }
                    _ => panic!("Unexpected result! Please report this bug."),
                }
                return Ok(());
            }
        }
        Some(PilotParserSub::ClearCache) => {
            match dispatcher.dispatch_command(PilotCommand::ClearCache, &[]).await {
                DispatchResult::CommandSuccess(Some(msg)) => println!("{}", Paint::green(msg)),
                DispatchResult::CommandFailed(e) => eprintln!("{e}"),
                _ => panic!("Unexpected result! Please report this bug."),
            }
            return Ok(());
        }
        None => { /* No pilot subcommand present; Continue */ }
    }

    // Create a new rustyline Editor
    let mut rl = Editor::<SolidityHelper, _>::new()?;
    rl.set_helper(Some(SolidityHelper::default()));

    // automatically add lines to history
    rl.set_auto_add_history(true);

    // load history
    if let Some(pilot_history) = pilot_history_file() {
        let _ = rl.load_history(&pilot_history);
    }

    // Print welcome header
    println!("Welcome to Pilot! Type `{}` to show available commands.", Paint::green("!help"));

    // Begin Rustyline loop
    loop {
        // Get the prompt from the dispatcher
        // Variable based on status of the last entry
        let prompt = dispatcher.get_prompt();
        rl.helper_mut().unwrap().set_errored(dispatcher.errored);

        // Read the next line
        let next_string = rl.readline(prompt.as_ref());

        // Try to read the string
        match next_string {
            Ok(line) => {
                // Clear interrupt flag
                interrupt = false;

                // Dispatch and match results
                match dispatcher.dispatch(&line).await {
                    DispatchResult::Success(msg) | DispatchResult::CommandSuccess(msg) => if let Some(msg) = msg {
                        println!("{}", Paint::green(msg));
                    },
                    DispatchResult::UnrecognizedCommand(e) => eprintln!("{e}"),
                    DispatchResult::SolangParserFailed(e) => {
                        eprintln!("{}", Paint::red("Compilation error"));
                        eprintln!("{}", Paint::red(format!("{e:?}")));
                    }
                    DispatchResult::FileIoError(e) => eprintln!("{}", Paint::red(format!("⚒️ Pilot File IO Error - {e}"))),
                    DispatchResult::CommandFailed(msg) | DispatchResult::Failure(Some(msg)) => eprintln!("{}", Paint::red(msg)),
                    DispatchResult::Failure(None) => eprintln!("{}\nPlease Report this bug as a github issue if it persists: https://github.com/orbitalis-rs/orbitalis/issues/new/choose", Paint::red("⚒️ Unknown Pilot Error ⚒️")),
                }
            }
            Err(ReadlineError::Interrupted) => {
                if interrupt {
                    break;
                } else {
                    println!("(To exit, press Ctrl+C again)");
                    interrupt = true;
                }
            }
            Err(ReadlineError::Eof) => break,
            Err(err) => {
                println!("Error: {err:?}");
                break;
            }
        }
    }

    if let Some(pilot_history) = pilot_history_file() {
        let _ = rl.save_history(&pilot_history);
    }

    Ok(())
}

/// [Provider] impl
impl Provider for PilotParser {
    fn metadata(&self) -> Metadata {
        Metadata::named("Script Args Provider")
    }

    fn data(&self) -> Result<Map<Profile, Dict>, orbitalis_config::figment::Error> {
        Ok(Map::from([(Config::selected_profile(), Dict::default())]))
    }
}
